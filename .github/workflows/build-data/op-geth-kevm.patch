commit fc235c19d8dfb4ffce2320ca9d3b4f70e8d1a5c6
Author: Stephen Skeirik <stephen.skeirik@pi2.network>
Date:   Sat May 17 13:35:59 2025 -0400

    add patch

diff --git a/core/state/statedb.go b/core/state/statedb.go
index e3f5b9e1a..33da12f9f 100644
--- a/core/state/statedb.go
+++ b/core/state/statedb.go
@@ -509,6 +509,14 @@ func (s *StateDB) SelfDestruct(addr common.Address) uint256.Int {
 	return prevBalance
 }
 
+func (s *StateDB) IsNewContract(addr common.Address) bool {
+	stateObject := s.getStateObject(addr)
+	if stateObject == nil {
+		return false
+	}
+	return stateObject.newContract
+}
+
 func (s *StateDB) SelfDestruct6780(addr common.Address) (uint256.Int, bool) {
 	stateObject := s.getStateObject(addr)
 	if stateObject == nil {
diff --git a/core/state/statedb_hooked.go b/core/state/statedb_hooked.go
index a2fdfe9a2..9e14bf39e 100644
--- a/core/state/statedb_hooked.go
+++ b/core/state/statedb_hooked.go
@@ -231,6 +231,14 @@ func (s *hookedStateDB) SelfDestruct(address common.Address) uint256.Int {
 	return prev
 }
 
+func (s *hookedStateDB) IsNewContract(address common.Address) bool {
+	stateObject := s.inner.stateObjects[address]
+	if stateObject == nil {
+		return false
+	}
+	return stateObject.newContract
+}
+
 func (s *hookedStateDB) SelfDestruct6780(address common.Address) (uint256.Int, bool) {
 	var prevCode []byte
 	var prevCodeHash common.Hash
diff --git a/core/vm/evm.go b/core/vm/evm.go
index c28dcb255..6a0967346 100644
--- a/core/vm/evm.go
+++ b/core/vm/evm.go
@@ -19,6 +19,7 @@ package vm
 import (
 	"errors"
 	"math/big"
+	"sync"
 	"sync/atomic"
 
 	"github.com/ethereum/go-ethereum/common"
@@ -30,6 +31,8 @@ import (
 	"github.com/holiman/uint256"
 )
 
+var kevmMutex sync.RWMutex
+
 type (
 	// CanTransferFunc is the signature of a transfer guard function
 	CanTransferFunc func(StateDB, common.Address, *uint256.Int) bool
@@ -119,6 +122,9 @@ type EVM struct {
 	// applied in opCall*.
 	callGasTemp uint64
 
+	// VLM
+	useKEVM bool
+
 	// precompiles holds the precompiled contracts for the current epoch
 	precompiles map[common.Address]PrecompiledContract
 
@@ -127,6 +133,10 @@ type EVM struct {
 	jumpDests map[common.Hash]bitvec
 }
 
+func (evm *EVM) SetUseKEVM(use bool) {
+	evm.useKEVM = use
+}
+
 // NewEVM constructs an EVM instance with the supplied block context, state
 // database and several configs. It meant to be used throughout the entire
 // state transition of a block, with the transaction context switched as
@@ -138,6 +148,7 @@ func NewEVM(blockCtx BlockContext, statedb StateDB, chainConfig *params.ChainCon
 		Config:      config,
 		chainConfig: chainConfig,
 		chainRules:  chainConfig.Rules(blockCtx.BlockNumber, blockCtx.Random != nil, blockCtx.Time),
+		useKEVM:     config.UseKEVM,
 		jumpDests:   make(map[common.Hash]bitvec),
 	}
 	evm.precompiles = activePrecompiledContracts(evm.chainRules)
@@ -193,68 +204,23 @@ func (evm *EVM) Call(caller common.Address, addr common.Address, input []byte, g
 			evm.captureEnd(evm.depth, startGas, leftOverGas, ret, err)
 		}(gas)
 	}
-	// Fail if we're trying to execute above the call depth limit
-	if evm.depth > int(params.CallCreateDepth) {
-		return nil, gas, ErrDepth
-	}
-	// Fail if we're trying to transfer more than the available balance
-	if !value.IsZero() && !evm.Context.CanTransfer(evm.StateDB, caller, value) {
-		return nil, gas, ErrInsufficientBalance
-	}
-	snapshot := evm.StateDB.Snapshot()
-	p, isPrecompile := evm.precompile(addr)
-
-	if !evm.StateDB.Exist(addr) {
-		if !isPrecompile && evm.chainRules.IsEIP4762 && !isSystemCall(caller) {
-			// add proof of absence to witness
-			wgas := evm.AccessEvents.AddAccount(addr, false)
-			if gas < wgas {
-				evm.StateDB.RevertToSnapshot(snapshot)
-				return nil, 0, ErrOutOfGas
-			}
-			gas -= wgas
-		}
-
-		if !isPrecompile && evm.chainRules.IsEIP158 && value.IsZero() {
-			// Calling a non-existing account, don't do anything.
-			return nil, gas, nil
-		}
-		evm.StateDB.CreateAccount(addr)
-	}
-	evm.Context.Transfer(evm.StateDB, caller, addr, value)
-
-	if isPrecompile {
-		ret, gas, err = RunPrecompiledContract(p, input, gas, evm.Config.Tracer)
-	} else {
-		// Initialise a new contract and set the code that is to be used by the EVM.
-		code := evm.resolveCode(addr)
-		if len(code) == 0 {
-			ret, err = nil, nil // gas is unchanged
-		} else {
-			// The contract is a scoped environment for this execution context only.
-			contract := NewContract(caller, addr, value, gas, evm.jumpDests)
-			contract.IsSystemCall = isSystemCall(caller)
-			contract.SetCallCode(evm.resolveCodeHash(addr), code)
-			ret, err = evm.interpreter.Run(contract, input, false)
-			gas = contract.Gas
-		}
-	}
-	// When an error was returned by the EVM or when setting the creation code
-	// above we revert to the snapshot and consume any gas remaining. Additionally,
-	// when we're in homestead this also counts for code storage gas errors.
-	if err != nil {
-		evm.StateDB.RevertToSnapshot(snapshot)
-		if err != ErrExecutionReverted {
-			if evm.Config.Tracer != nil && evm.Config.Tracer.OnGasChange != nil {
-				evm.Config.Tracer.OnGasChange(gas, 0, tracing.GasChangeCallFailedExecution)
-			}
-
-			gas = 0
-		}
-		// TODO: consider clearing up unused snapshots:
-		//} else {
-		//	evm.StateDB.DiscardSnapshot(snapshot)
-	}
+	kevmMutex.Lock()
+	kevm := NewKEVM(evm.Context, evm.TxContext, evm.StateDB, evm.chainConfig, evm.chainRules)
+	var schedule = kevm.getSchedule()
+	var block = kevm.getBlock()
+	var code = evm.resolveCode(addr)
+	var blobHashes = evm.TxContext.BlobHashes
+	var message = kevm.getMessage(caller, addr, false, gas, value, input, code, blobHashes)
+	var substate = kevm.getSubstate()
+	if witness := evm.StateDB.Witness(); witness != nil {
+		witness.AddCode(code)
+	}
+	result, gas := kevm.executeCallFrame(schedule, block, message, substate)
+	kevm.applySubstate(substate)
+	ret = kevm.getOutput(result)
+	err = kevm.getError(result)
+	kevm.cleanup(block, message, substate, result)
+	kevmMutex.Unlock()
 	return ret, gas, err
 }
 
@@ -448,67 +414,20 @@ func (evm *EVM) create(caller common.Address, code []byte, gas uint64, value *ui
 	if evm.chainRules.IsEIP2929 {
 		evm.StateDB.AddAddressToAccessList(address)
 	}
-	// Ensure there's no existing contract already at the designated address.
-	// Account is regarded as existent if any of these three conditions is met:
-	// - the nonce is non-zero
-	// - the code is non-empty
-	// - the storage is non-empty
-	contractHash := evm.StateDB.GetCodeHash(address)
-	storageRoot := evm.StateDB.GetStorageRoot(address)
-	if evm.StateDB.GetNonce(address) != 0 ||
-		(contractHash != (common.Hash{}) && contractHash != types.EmptyCodeHash) || // non-empty code
-		(storageRoot != (common.Hash{}) && storageRoot != types.EmptyRootHash) { // non-empty storage
-		if evm.Config.Tracer != nil && evm.Config.Tracer.OnGasChange != nil {
-			evm.Config.Tracer.OnGasChange(gas, 0, tracing.GasChangeCallFailedExecution)
-		}
-		return nil, common.Address{}, 0, ErrContractAddressCollision
-	}
-	// Create a new account on the state only if the object was not present.
-	// It might be possible the contract code is deployed to a pre-existent
-	// account with non-zero balance.
-	snapshot := evm.StateDB.Snapshot()
-	if !evm.StateDB.Exist(address) {
-		evm.StateDB.CreateAccount(address)
-	}
-	// CreateContract means that regardless of whether the account previously existed
-	// in the state trie or not, it _now_ becomes created as a _contract_ account.
-	// This is performed _prior_ to executing the initcode,  since the initcode
-	// acts inside that account.
-	evm.StateDB.CreateContract(address)
-
-	if evm.chainRules.IsEIP158 {
-		evm.StateDB.SetNonce(address, 1, tracing.NonceChangeNewContract)
-	}
-	// Charge the contract creation init gas in verkle mode
-	if evm.chainRules.IsEIP4762 {
-		statelessGas := evm.AccessEvents.ContractCreateInitGas(address)
-		if statelessGas > gas {
-			return nil, common.Address{}, 0, ErrOutOfGas
-		}
-		if evm.Config.Tracer != nil && evm.Config.Tracer.OnGasChange != nil {
-			evm.Config.Tracer.OnGasChange(gas, gas-statelessGas, tracing.GasChangeWitnessContractInit)
-		}
-		gas = gas - statelessGas
-	}
-	evm.Context.Transfer(evm.StateDB, caller, address, value)
-
-	// Initialise a new contract and set the code that is to be used by the EVM.
-	// The contract is a scoped environment for this execution context only.
-	contract := NewContract(caller, address, value, gas, evm.jumpDests)
-
-	// Explicitly set the code to a null hash to prevent caching of jump analysis
-	// for the initialization code.
-	contract.SetCallCode(common.Hash{}, code)
-	contract.IsDeployment = true
-
-	ret, err = evm.initNewContract(contract, address)
-	if err != nil && (evm.chainRules.IsHomestead || err != ErrCodeStoreOutOfGas) {
-		evm.StateDB.RevertToSnapshot(snapshot)
-		if err != ErrExecutionReverted {
-			contract.UseGas(contract.Gas, evm.Config.Tracer, tracing.GasChangeCallFailedExecution)
-		}
-	}
-	return ret, address, contract.Gas, err
+	kevmMutex.Lock()
+	kevm := NewKEVM(evm.Context, evm.TxContext, evm.StateDB, evm.chainConfig, evm.chainRules)
+	var schedule = kevm.getSchedule()
+	var block = kevm.getBlock()
+	var blobHashes = evm.TxContext.BlobHashes
+	var message = kevm.getMessage(caller, address, true, gas, value, []byte{}, code, blobHashes)
+	var substate = kevm.getSubstate()
+	result, gas := kevm.executeCallFrame(schedule, block, message, substate)
+	kevm.applySubstate(substate)
+	ret = kevm.getOutput(result)
+	err = kevm.getError(result)
+	kevm.cleanup(block, message, substate, result)
+	kevmMutex.Unlock()
+	return ret, address, gas, err
 }
 
 // initNewContract runs a new contract's creation code, performs checks on the
diff --git a/core/vm/interface.go b/core/vm/interface.go
index 57f35cb24..e42ace75c 100644
--- a/core/vm/interface.go
+++ b/core/vm/interface.go
@@ -39,6 +39,7 @@ type StateDB interface {
 	GetNonce(common.Address) uint64
 	SetNonce(common.Address, uint64, tracing.NonceChangeReason)
 
+	IsNewContract(common.Address) bool
 	GetCodeHash(common.Address) common.Hash
 	GetCode(common.Address) []byte
 
diff --git a/core/vm/interpreter.go b/core/vm/interpreter.go
index a0038d1aa..316df2f82 100644
--- a/core/vm/interpreter.go
+++ b/core/vm/interpreter.go
@@ -33,7 +33,7 @@ type Config struct {
 	NoBaseFee               bool  // Forces the EIP-1559 baseFee to 0 (needed for 0 price calls)
 	EnablePreimageRecording bool  // Enables recording of SHA3/keccak preimages
 	ExtraEips               []int // Additional EIPS that are to be enabled
-
+	UseKEVM                 bool
 	StatelessSelfValidation bool // Generate execution witnesses and self-check against them (testing purpose)
 }
 
diff --git a/tests/block_test.go b/tests/block_test.go
index f146e4ee6..128d9ce8b 100644
--- a/tests/block_test.go
+++ b/tests/block_test.go
@@ -17,7 +17,6 @@
 package tests
 
 import (
-	"math/rand"
 	"testing"
 
 	"github.com/ethereum/go-ethereum/common"
@@ -92,20 +91,8 @@ func execBlockTest(t *testing.T, bt *testMatcher, test *BlockTest) {
 	//
 	// Note, witness building and self-testing is always enabled as it's a very
 	// good test to ensure that we don't break it.
-	var (
-		snapshotConf = []bool{false, true}
-		dbschemeConf = []string{rawdb.HashScheme, rawdb.PathScheme}
-	)
-	if testing.Short() {
-		snapshotConf = []bool{snapshotConf[rand.Int()%2]}
-		dbschemeConf = []string{dbschemeConf[rand.Int()%2]}
-	}
-	for _, snapshot := range snapshotConf {
-		for _, dbscheme := range dbschemeConf {
-			if err := bt.checkFailure(t, test.Run(snapshot, dbscheme, true, nil, nil)); err != nil {
-				t.Errorf("test with config {snapshotter:%v, scheme:%v} failed: %v", snapshot, dbscheme, err)
-				return
-			}
-		}
+	if err := bt.checkFailure(t, test.Run(false, rawdb.HashScheme, false, nil, nil)); err != nil {
+		t.Errorf("test with config {snapshotter:%v, scheme:%v} failed: %v", false, rawdb.HashScheme, err)
+		return
 	}
 }
